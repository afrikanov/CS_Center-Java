Добрый день, ребята! Студенты пишут много писем с очень похожими вопросами и проблемами.
У студентов очень много похожих недочетов в коде.    
Перед тем, как в следующий раз написать мне письмо или отправить решение на проверку, посмотрите этот пост,
возможно он вам поможет.

## Калькулятор.

### 1.1: Допустимы ли конструкции вида \$SOME\_STRANGE\_EXPRESSION? А правда, что ответ на \$ANOTHER\_EXPRESSION должен быть \$ANSWER1, на не \$ANSWER2?
Советую вам проверять возможность написания некоторого выражения, пользуясь интерпретатором `python` в качестве калькулятора.
Там можно проверить, можно ли написать __\$SOME\_STRANGE\_EXPRESSION__ и какой будет ответ на __\$ANOTHER\_EXPRESSION__.
[Здесь](https://www.python.org/) есть интерактивная консолька, если у вас не стоит python.
Разница будет в том, что знак `^` меняется на `**` и, функции нужно вызывать, предварительно написав команду `from math import *`

### 1.2: Как реализовать это место, чтобы было красиво и вам понравилось на код-ревью?    
Вы как-нибудь напишите, а на код ревью разберёмся. За самыми частыми проблемами в коде смотрите FAQ дальше.
 
### 1.3: Отправил на проверку калькулятор, но он не прошел \$N тестов, хотелось узнать, что да как.   
Если __\$N__ равно 14, значит вы либо неправильно указали свой класс в настройках,
либо не указали в сигнатуре этого класса, что он реализовывает `Calculator`,
либо вы сдаете что-то, что неправильно работает даже при тесте «0»   
Если __\$N__ равно 13, и вы уверены, что хоть как-то ваша программа должна работать, обратите внимание на тот факт,
что после создания объекта вашего класса, метод `calculate` может вызываться у него больше, чем один раз.
Логично, мы же не выключаем калькулятор каждый раз, когда хотим написать туда новое выражение, верно? :)  
Если __\$N__ равно 1 и это тест `testDoubleScientificFormat`, то постарайтесь считывать числа с большим количеством знаков
и большим порядком максимально точно. Мои тесты сделаны так, что преобразования тестовых чисел из строк в double средствами языка работает прекрасно.
Не нужно писать велосипедов.   
Иначе – нужно думать :( Тесты я вам не сдам, они генерируются случайным образом и по ним уже сдалось несколько человек, название теста не отображает единственную вещь,
которую ваша программа должна поддерживать, чтобы пройти его.

## Code Review
Здесь описаны вещи, которые я вас попрошу поправить в любом случае.
Посмотрите, пожалуйста, этот список перед тем, как посылать мне решение.   
Все совпадения с кодом студентов случайны.

### 2.1: Названия переменных, методов, классов   
Переменные стоит называть полными словами, максимально понятно. (исключения – `i`, `j`, `k`, традиционные названия для итераций в цикле)
Я могу читать ваш код и не сразу понимать, что переменная хранит.
Не используйте сокращенные названия методов и переменных. Зачем писать `op`, когда можно написать `operator`?
Я не буду сильно думать над переменными в духе `cur`, `expr` и `res`.
Но что вам мешало написать полное название и сделать код читающимся так же просто, как стихи Агнии Барто?

### 2.2: Гиганские нечитабельные методы и выражения
Если у вас есть метод на 100 строк,
который сопровожден комментариями в духе
«А здесь я справляюсь с пробелами, а здесь я разбираю функции»,
скорей всего этот метод делает очень много. Метод должен быть небольшим,
осознаваемым полностью, решать одну задачу и все действия в нем должны быть написаны на одном уровне абстракции.
Как исправить? Выделяйте куски метода в другие методы и называйте их семантически ясно и точно!

Рассмотрим хороший пример операций на одном уровне абстрации (в примерах не обязательно корректный Java код):

        processBrackets();
        removeSpaces();
        processBinaryOperators();
        processFunctions();
        итд  

рассмотрим плохой пример.

        processBrackets();
        for (char c: expression.toCharArray()) {
            if (c == ' ' || c == '\n' || c == '\u00A0') {
                expression = expression.removeChar(c)
            }
        }
        processBinaryOperators();
        processFunctions();
        итд  

Заметьте, в одном и том же методе мы делаем операции на совершенно разных уровнях абстракции
(удаляем символы из строки – очень низкоуровнево).
Читабельность убита, проверка домашек затягивается, настроение портится, задания страшнеют, дедлайны сокращаются :)

А вы сможете разобраться с подобным условным выражением?

        (flag) && (strExpression.charAt(i) == '+') && (balance == 0)
        && (strExpression.charAt(i - 1) != 'e')  &&
        (strExpression.charAt(i - 1) != '^') && (strExpression.charAt(i - 1) != '-')
        && (strExpression.charAt(i - 1) != '+') && (strExpression.charAt(i - 1) != '*')
        && (strExpression.charAt(i - 1) != '/')

Что оно делает? Я не знаю. Но очень интересно! Я хочу узнать что делает такое сложное условное выражение!
И я понял бы, если бы кусочки этого выражения были бы выделены в читабельные, по человечески названные методы.
Или хотя бы целое выражение.
             

### 2.3: Magic numbers
Кстати, что такое `\u00A0` из предыдущего примера? А черт его знает.    
Вы никогда не поймете, что это, если будете просто читать чужой код.
Но что, если выражение будет написано так:

    if (c == ' ' || c == '\n' || c == NO_BREAK_SPACE_SYMBOL) {
Как до нас раньше не дошло, это же неразрывный пробел!
Всегда выделяйте «магические числа» в константы и называйте их так, чтобы читателю было очевидно, что это. 
     
         
### 2.4: Дублирование кода   
Бич всех домашек, да и в целом, программирования. Это настоящее искуство – элегантно избавиться от дубликации кода.

Дубликация кода разной, ее не всегда можно заметить.
Самое простое, если вы городите адское условное выражение, где каждая часть выражения безумно похожа:
       
        else if (expression.contains("SIN")){
          i = expression.indexOf("SIN");
          rExpr = expression.substring(i + 3);
          result = Math.sin(calculate(rExpr));
        }
        else if (expression.contains("COS")){
          i = expression.indexOf("COS");
          rExpr = expression.substring(i + 3);
          result = Math.cos(calculate(rExpr));
        }
        else if (expression.contains("ABS")){
          i = expression.indexOf("ABS");
          rExpr = expression.substring(i + 3);
          result = Math.abs(calculate(rExpr));
        }
Посмотрите, как много тут дубликации кода! :) Представьте, что функций не 3, а 30.
Вы хорошо представляете себе код, который будет обрабатывать в такой же манере такое количество функций?
Не важно, функций стало 30, мы все сделали быстро, методом copy-paste. Допустим вы где-то, при копировании,
сделали ошибку. Через сколько времени вы её заметите? Copy-paste - источник очень трудноуловимых ошибок.
Самое интересное. Вам нужно поменять тело повторяющегося кода, допустим, поменят функцию `indexOf` на что-то другое.
Представляете, сколько матов вы мысленно скажете при изменении одного и того же места 30 раз?

Как бороться. Самое простое – выделить одинаковый кусок в метод. Самое хорошее – задуматься об иерархии классов,
задающих объекты, которые действуют похожим образом, абстрагировать одинаковый код, а с помощью полиморфизма
управлять различиями.
Если у вас есть множество однотипных объектов (типа функций с одним аргументом), заведите под них класс.
Если мы хотим ограничить возможный список функций, воспользуйтесь классом-перечислением, и перечислите все допустимые объекты в нем.
Добавить новую функцию не составит труда. С конструировать функцию по ее имени – тоже (обращаем внимание на методы `values()` и `valueOf`).

В общем случае использовать Enum для таких целей – решение спорное (не значит плохое, значит – не всегда уместное).
Вы пока не обладаете знаниями для идеального решения,
но сейчас Enum в качестве способа получения объекта из ограниченного пула по имени и реализации полиморфного поведения вполне подойдет.
Например, применение функции в калькуляторе должно быть написано без единого if'а и switch'а. __It's polymorphism, baby.__

### 2.5: Неизменяемость строк в Java
Если вы, в вашем решении, часто изменяете строку (в цикле удаляете пробелы, например), то делать это напрямую не очень хорошо.
Строки в Java неизменяемы, поэтому удаление пробелов у вас будет работать довольно неэффективно.
Обратите внимание на `StringBuilder` или `StringBuffer`.
 
### 2.6: Один класс отвечает за несколько процессов
Часто бывает, что класс-реализация `Calculator` занимается сразу двумя вещами: разбором строки на лексемы и вычислением выражения.
Разделяйте эти зоны ответственности на два класса. Так вы абстрагируете два процесса и избавляетесь от ненужных зависимостей. Опять же, все становится гораздо ясней.

### 2.7: Пробелы
Бинарные операторы должны быть окружены пробелами.
Операторы присвоения должны быть окружены пробелами.
После запятых нужно ставить пробелы.
Перед открывающими блок кода фигурными скобками должен быть пробел.

### 2.8: camelCase
Все названия объектов в коде в Java пишутся camelCase'ом. Кроме констант.
Они пишутся большими буквами, разделяя слова нижними подчеркиваниями.
Классы пишутся с большой буквы, все остальное с маленькой.
Нижние подчеркивания оставьте для C++ и Python.


Я верю, что у вас все получится и домашние задания не будут вызывать боль, обиду и желание удушить составителя задачек :)
Удачи!